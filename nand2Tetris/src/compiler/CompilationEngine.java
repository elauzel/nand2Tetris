package compiler;

import java.io.BufferedWriter;
import java.io.IOException;
import static utility.Utils.*;

/**
 * Recursive top-down parser that effects the actual compilation output. Gets its input from a JackTokenizer and emits its parsed structure into an
 * output file/stream. The output is generated by a series of compilexxx() routines, one for every syntactic element xxx of the Jack grammar. The
 * contract between these routines is that each compilexxx() routine should read the syntactic construct xxx from the input, advance() the tokenizer
 * exactly beyond xxx, and output the parsing of xxx. Thus, compilexxx() may only be called if indeed xxx is the next syntactic element of the
 * input.
 * 
 * @author Jeremy Wayne Gilreath
 *
 */
public class CompilationEngine {
	private static final String	OP_SYMBOLS	= "+-*/&|<>=";

	private BufferedWriter		bw;

	private JackTokenizer		tokenizer;

	private int					indents;

	/**
	 * Creates a new compilation engine with the given input and output. The next routine called must be compileClass().
	 */
	public CompilationEngine(String output, JackTokenizer jt) {
		bw = bufferedWriterFor(output);
		tokenizer = jt;
		indents = 0;
	}

	/**
	 * Compiles a complete class.
	 */
	public void compileClass() {
		// Class: 'class' className '{' classVarDec* subroutineDec* '}'
		// className: identifier

		// DEBUG_PRINT("<class>");

		// <class>
		writeXML("class", false);
		tokenizer.advance();

		// 'class'
		expectKeyWord(KeyWord.CLASS);
		writeXML("keyword", "class");
		tokenizer.advance();

		// className
		String className = expectIdentifier();
		writeXML("identifier", className);
		tokenizer.advance();

		// '{'
		expectSymbol('{');
		writeXML("symbol", "{");
		tokenizer.advance();

		// classVarDec* -> 'static' | 'field'
		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if ((tokenizer.keyWord() == KeyWord.STATIC) || (tokenizer.keyWord() == KeyWord.FIELD)) {
				compileClassVarDec();
			} else {
				break;
			}
		}

		// subroutineDec* -> 'constructor' | 'function' | 'method'
		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if ((tokenizer.keyWord() == KeyWord.CONSTRUCTOR)
					|| (tokenizer.keyWord() == KeyWord.FUNCTION || (tokenizer.keyWord() == KeyWord.METHOD))) {
				compileSubroutine();
			} else {
				break;
			}
		}

		// '}'
		expectSymbol('}');
		writeXML("symbol", "}");
		tokenizer.advance();

		// </class>
		writeXML("class", true);

		// DEBUG_PRINT("</class>");

		if (tokenizer.hasMoreLines()) {
			throwException("Junk after end of class definition!");
		}
	}

	/**
	 * Compiles a static declaration or a field declaration.
	 */
	private void compileClassVarDec() {
		// ('static' | 'field') type varName (',' varName)* ';'
		// type: 'int' | 'char' | 'boolean' | className
		// varname: identifier
		// className: identifier

		// DEBUG_PRINT("<classVarDec>");

		// <classVarDec>
		writeXML("classVarDec", false);

		// ('static' | 'field')
		if (tokenizer.keyWord() == KeyWord.STATIC) writeXML("keyword", "static");
		if (tokenizer.keyWord() == KeyWord.FIELD) writeXML("keyword", "field");
		tokenizer.advance();

		// type -> 'int' | 'char' | 'boolean' | className
		if (tokenizer.tokenType() == TokenType.KEYWORD) {
			if (tokenizer.keyWord() == KeyWord.INT) writeXML("keyword", "int");
			if (tokenizer.keyWord() == KeyWord.CHAR) writeXML("keyword", "char");
			if (tokenizer.keyWord() == KeyWord.BOOLEAN) writeXML("keyword", "boolean");
		} else {
			String className = expectIdentifier();
			writeXML("identifier", className);
		}
		tokenizer.advance();

		// varName -> identifier
		String varName = expectIdentifier();
		writeXML("identifier", varName);
		tokenizer.advance();

		// (',' varName)*
		while (true) {
			if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
			writeXML("symbol", ",");
			tokenizer.advance();

			String varX = expectIdentifier();
			writeXML("identifier", varX);
			tokenizer.advance();
		}

		// ';'
		expectSymbol(';');
		writeXML("symbol", ";");
		tokenizer.advance();

		// </classVarDec>
		writeXML("classVarDec", true);

		// DEBUG_PRINT("</classVarDec>");
	}

	/**
	 * Compiles a complete method, function, or constructor.
	 */
	private void compileSubroutine() {
		// subroutineDec: ('constructor' | 'function' | 'method') ('void' | type) subroutineName '(' parameterList ')' subroutineBody
		// subroutineName: identifier
		// subroutineBody: '{' varDec* statements '}'
		// type: 'int' | 'char' | 'boolean' | className
		// className: identifier

		// DEBUG_PRINT("<subroutine>");

		// <subroutineDec>
		writeXML("subroutineDec", false);

		// ('constructor' | 'function' | 'method')
		if (tokenizer.keyWord() == KeyWord.CONSTRUCTOR) writeXML("keyword", "constructor");
		if (tokenizer.keyWord() == KeyWord.FUNCTION) writeXML("keyword", "function");
		if (tokenizer.keyWord() == KeyWord.METHOD) writeXML("keyword", "method");
		tokenizer.advance();

		// ('void' | type) -> 'void' | ('int' | 'char' | 'boolean' | className)
		if (tokenizer.tokenType() == TokenType.KEYWORD) {
			if (tokenizer.keyWord() == KeyWord.VOID) writeXML("keyword", "void");
			if (tokenizer.keyWord() == KeyWord.INT) writeXML("keyword", "int");
			if (tokenizer.keyWord() == KeyWord.CHAR) writeXML("keyword", "char");
			if (tokenizer.keyWord() == KeyWord.BOOLEAN) writeXML("keyword", "boolean");
		}
		if (tokenizer.tokenType() == TokenType.IDENTIFIER) {
			String className = expectIdentifier();
			writeXML("identifier", className);
		}
		tokenizer.advance();

		// subroutineName -> identifier
		String subroutineName = expectIdentifier();
		writeXML("identifier", subroutineName);
		tokenizer.advance();

		// '(' parameterList ')' -> '(' ('int' | 'char' | 'boolean' | className) ')'
		expectSymbol('(');
		writeXML("symbol", "(");
		tokenizer.advance();

		// if (tokenizer.tokenType() == TokenType.KEYWORD || tokenizer.tokenType() == TokenType.IDENTIFIER) compileParameterList();
		compileParameterList();

		expectSymbol(')');
		writeXML("symbol", ")");
		tokenizer.advance();

		// subroutineBody -> '{' varDec* statements '}'

		// DEBUG_PRINT("<subroutineBody>");

		// <subroutineBody>
		writeXML("subroutineBody", false);

		expectSymbol('{');
		writeXML("symbol", "{");
		tokenizer.advance();

		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if (tokenizer.keyWord() == KeyWord.VAR) {
				compileVarDec();
			} else {
				break;
			}
		}

		compileStatements();

		expectSymbol('}');
		writeXML("symbol", "}");
		tokenizer.advance();

		// </subroutineBody>
		writeXML("subroutineBody", true);

		// DEBUG_PRINT("</subroutineBody>");

		// </subroutineDec>
		writeXML("subroutineDec", true);

		// DEBUG_PRINT("</subroutine>");
	}

	/**
	 * Compiles a (possibly empty) parameter list, not including the enclosing "()".
	 */
	private void compileParameterList() {
		// ((type varName) (',' type varName)*)?
		// type: 'int' | 'char' | 'boolean' | className
		// varname: identifier
		// className: identifier

		// DEBUG_PRINT("<parameterList>");

		// <parameterList>
		writeXML("parameterList", false);

		if (tokenizer.tokenType() == TokenType.KEYWORD || tokenizer.tokenType() == TokenType.IDENTIFIER) {
			// type -> 'int' | 'char' | 'boolean' | className
			if (tokenizer.tokenType() == TokenType.KEYWORD) {
				if (tokenizer.keyWord() == KeyWord.INT) writeXML("keyword", "int");
				if (tokenizer.keyWord() == KeyWord.CHAR) writeXML("keyword", "char");
				if (tokenizer.keyWord() == KeyWord.BOOLEAN) writeXML("keyword", "boolean");
			}
			if (tokenizer.tokenType() == TokenType.IDENTIFIER) {
				String className = expectIdentifier();
				writeXML("identifier", className);
			}
			tokenizer.advance();

			// varName -> identifier
			String varName = expectIdentifier();
			writeXML("identifier", varName);
			tokenizer.advance();

			// (',' type varName)*
			while (true) {
				if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
				writeXML("symbol", ",");
				tokenizer.advance();

				if (tokenizer.tokenType() == TokenType.KEYWORD) {
					if (tokenizer.keyWord() == KeyWord.INT) writeXML("keyword", "int");
					if (tokenizer.keyWord() == KeyWord.CHAR) writeXML("keyword", "char");
					if (tokenizer.keyWord() == KeyWord.BOOLEAN) writeXML("keyword", "boolean");
				}
				if (tokenizer.tokenType() == TokenType.IDENTIFIER) {
					String classX = expectIdentifier();
					writeXML("identifier", classX);
				}
				tokenizer.advance();

				String varX = expectIdentifier();
				writeXML("identifier", varX);
				tokenizer.advance();
			}

		}

		// </parameterList>
		writeXML("parameterList", true);

		// DEBUG_PRINT("</parameterList>");
	}

	/**
	 * Compiles a var declaration.
	 */
	private void compileVarDec() {
		// 'var' type varname (',' varName)* ';'
		// type: 'int' | 'char' | 'boolean' | className
		// varname: identifier
		// className: identifier

		// DEBUG_PRINT("<varDec>");

		// <varDec>
		writeXML("varDec", false);

		// 'var'
		expectKeyWord(KeyWord.VAR);
		writeXML("keyword", "var");
		tokenizer.advance();

		// type -> 'int' | 'char' | 'boolean' | className
		if (tokenizer.tokenType() == TokenType.KEYWORD) {
			if (tokenizer.keyWord() == KeyWord.INT) writeXML("keyword", "int");
			if (tokenizer.keyWord() == KeyWord.CHAR) writeXML("keyword", "char");
			if (tokenizer.keyWord() == KeyWord.BOOLEAN) writeXML("keyword", "boolean");
		} else {
			String className = expectIdentifier();
			writeXML("identifier", className);
		}
		tokenizer.advance();

		// varName -> identifier
		String varName = expectIdentifier();
		writeXML("identifier", varName);
		tokenizer.advance();

		// (',' varName)*
		while (true) {
			if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
			writeXML("symbol", ",");
			tokenizer.advance();

			String varX = expectIdentifier();
			writeXML("identifier", varX);
			tokenizer.advance();
		}

		// ';'
		expectSymbol(';');
		writeXML("symbol", ";");
		tokenizer.advance();

		// </varDec>
		writeXML("varDec", true);

		// DEBUG_PRINT("</varDec>");
	}

	/**
	 * Compiles a sequence of statements, not including the enclosing "{}".
	 */
	private void compileStatements() {
		// statement*
		// statement: letStatement | ifStatement | whileStatement | doStatement | returnStatement

		// DEBUG_PRINT("<statements>");

		// <statements>
		writeXML("statements", false);

		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if (tokenizer.keyWord() == KeyWord.LET) {
				compileLet();
			} else if (tokenizer.keyWord() == KeyWord.IF) {
				compileIf();
			} else if (tokenizer.keyWord() == KeyWord.WHILE) {
				compileWhile();
			} else if (tokenizer.keyWord() == KeyWord.DO) {
				compileDo();
			} else if (tokenizer.keyWord() == KeyWord.RETURN) {
				compileReturn();
			}
		}

		// </statements>
		writeXML("statements", true);

		// DEBUG_PRINT("</statements>");
	}

	/**
	 * Compiles a do statement.
	 */
	private void compileDo() {
		// 'do' subroutineCall ';'
		// subroutineCall: subroutineName '(' expressionList ')' | (className | varName) '.' subroutineName '(' expressionList ')'
		// subroutineName: identifier
		// className: identifier
		// varName: identifier

		// DEBUG_PRINT("<do>");

		// <do>
		writeXML("doStatement", false);

		// 'do'
		expectKeyWord(KeyWord.DO);
		writeXML("keyword", "do");
		tokenizer.advance();

		// subroutineCall -> subroutineName | (className | varName) -> identifier
		String name = expectIdentifier();
		writeXML("identifier", name);
		tokenizer.advance();

		// '.' subroutineName
		if (tokenizer.tokenType() == TokenType.SYMBOL && tokenizer.symbol() == '.') {
			writeXML("symbol", ".");
			tokenizer.advance();

			String subroutineName = expectIdentifier();
			writeXML("identifier", subroutineName);
			tokenizer.advance();
		}

		// '(' expressionList ')'
		expectSymbol('(');
		writeXML("symbol", "(");
		tokenizer.advance();

		compileExpressionList();

		expectSymbol(')');
		writeXML("symbol", ")");
		tokenizer.advance();

		// ';'
		expectSymbol(';');
		writeXML("symbol", ";");
		tokenizer.advance();

		// </do>
		writeXML("doStatement", true);

		// DEBUG_PRINT("</do>");
	}

	/**
	 * Compiles a let statement.
	 */
	private void compileLet() {
		// 'let' varName ('[' expression ']')? '=' expression ';'
		// varname: identifier

		// DEBUG_PRINT("<let>");

		// <let>
		writeXML("letStatement", false);

		// 'let'
		expectKeyWord(KeyWord.LET);
		writeXML("keyword", "let");
		tokenizer.advance();

		// varName -> identifier
		String varName = expectIdentifier();
		writeXML("identifier", varName);
		tokenizer.advance();

		// ('[' expression ']')?
		if (tokenizer.tokenType() == TokenType.SYMBOL && tokenizer.symbol() == '[') {
			writeXML("symbol", "[");
			tokenizer.advance();

			compileExpression();

			expectSymbol(']');
			writeXML("symbol", "]");
			tokenizer.advance();
		}

		// '='
		expectSymbol('=');
		writeXML("symbol", "=");
		tokenizer.advance();

		// expression
		compileExpression();

		// ';'
		expectSymbol(';');
		writeXML("symbol", ";");
		tokenizer.advance();

		// </let>
		writeXML("letStatement", true);

		// DEBUG_PRINT("</let>");
	}

	/**
	 * Compiles a while statement.
	 */
	private void compileWhile() {
		// 'while' '(' expression ')' '{' statements '}'

		// DEBUG_PRINT("<while>");

		// <while>
		writeXML("whileStatement", false);

		// 'while'
		expectKeyWord(KeyWord.WHILE);
		writeXML("keyword", "while");
		tokenizer.advance();

		// '(' expression ')'
		expectSymbol('(');
		writeXML("symbol", "(");
		tokenizer.advance();

		compileExpression();

		expectSymbol(')');
		writeXML("symbol", ")");
		tokenizer.advance();

		// '{' statements '}'
		expectSymbol('{');
		writeXML("symbol", "{");
		tokenizer.advance();

		compileStatements();

		expectSymbol('}');
		writeXML("symbol", "}");
		tokenizer.advance();

		// </while>
		writeXML("whileStatement", true);

		// DEBUG_PRINT("</while>");
	}

	/**
	 * Compiles a return statement.
	 */
	private void compileReturn() {
		// 'return' expression? ';'

		// DEBUG_PRINT("<return>");

		// <return>
		writeXML("returnStatement", false);

		// 'return'
		expectKeyWord(KeyWord.RETURN);
		writeXML("keyword", "return");
		tokenizer.advance();

		// expression?
		if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ';') compileExpression();

		// ';'
		expectSymbol(';');
		writeXML("symbol", ";");
		tokenizer.advance();

		// </return>
		writeXML("returnStatement", true);

		// DEBUG_PRINT("</return>");
	}

	/**
	 * Compiles an if statement, possibly with a trailing else clause.
	 */
	private void compileIf() {
		// 'if' '(' expression ')' '{' statements '}' ('else' '{' statements '}')?

		// DEBUG_PRINT("<if>");

		// <if>
		writeXML("ifStatement", false);

		// 'if'
		expectKeyWord(KeyWord.IF);
		writeXML("keyword", "if");
		tokenizer.advance();

		// '(' expression ')'
		expectSymbol('(');
		writeXML("symbol", "(");
		tokenizer.advance();

		compileExpression();

		expectSymbol(')');
		writeXML("symbol", ")");
		tokenizer.advance();

		// '{' statements '}'
		expectSymbol('{');
		writeXML("symbol", "{");
		tokenizer.advance();

		compileStatements();

		expectSymbol('}');
		writeXML("symbol", "}");
		tokenizer.advance();

		// ('else' '{' statements '}')?
		if (tokenizer.tokenType() == TokenType.KEYWORD && tokenizer.keyWord() == KeyWord.ELSE) {
			writeXML("keyword", "else");
			tokenizer.advance();

			expectSymbol('{');
			writeXML("symbol", "{");
			tokenizer.advance();

			compileStatements();

			expectSymbol('}');
			writeXML("symbol", "}");
			tokenizer.advance();
		}

		// </if>
		writeXML("ifStatement", true);

		// DEBUG_PRINT("</if>");

	}

	/**
	 * Compiles an expression.
	 */
	private void compileExpression() {
		// term (op term)*
		// op: '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='

		// DEBUG_PRINT("<expression>");

		// <expression>
		writeXML("expression", false);

		// term
		compileTerm();

		// (op term)*
		while (true) {
			if (tokenizer.tokenType() != TokenType.SYMBOL) break;
			if (OP_SYMBOLS.indexOf(tokenizer.symbol()) == -1) break;
			String op = "" + tokenizer.symbol();
			writeXML("symbol", op);
			tokenizer.advance();

			compileTerm();
		}

		// </expression>
		writeXML("expression", true);

		// DEBUG_PRINT("</expression>");
	}

	/**
	 * Compiles a term. This routine is faced with a slight difficulty when trying to decide between some of the alternative parsing rules.
	 * Specifically, if the current token is an identifier, the routine must distinguish between a variable, an array entry, and a subroutine call.
	 * A single look-ahead token, which may be one of "[", "(", or "." suffices to distinguish between the three possibilities. Any other token is
	 * not part of this term and should not be advanced over.
	 */
	private void compileTerm() {
		// integerConstant | stringConstant | keywordConstant | varName | varName '[' expression ']' | subroutineCall | '(' expression ')' | unaryOp
		// term
		// varname: identifier
		// subroutineCall: subroutineName '(' expressionList ')' | (className | varname) '.' subroutineName '(' expressionList ')'
		// unaryOp: '-' | '~'
		// keywordConstant: 'true' | 'false' | 'null' | 'this'

		// DEBUG_PRINT("<term>");

		// <term>
		writeXML("term", false);

		// keywordConstant -> 'true' | 'false' | 'null' | 'this' -> KEYWORD
		if (tokenizer.tokenType() == TokenType.KEYWORD
				&& (tokenizer.keyWord() == KeyWord.TRUE || tokenizer.keyWord() == KeyWord.FALSE
						|| tokenizer.keyWord() == KeyWord.NULL || tokenizer.keyWord() == KeyWord.THIS)) {
			if (tokenizer.keyWord() == KeyWord.TRUE) writeXML("keyword", "true");
			if (tokenizer.keyWord() == KeyWord.FALSE) writeXML("keyword", "false");
			if (tokenizer.keyWord() == KeyWord.NULL) writeXML("keyword", "null");
			if (tokenizer.keyWord() == KeyWord.THIS) writeXML("keyword", "this");
			tokenizer.advance();
		}

		// '(' expression ')' | unaryOp term ->
		// '(' expression ')' | ('-' | '~') term -> SYMBOL
		if (tokenizer.tokenType() == TokenType.SYMBOL) {
			if (tokenizer.symbol() == '(') {
				expectSymbol('(');
				writeXML("symbol", "(");
				tokenizer.advance();

				compileExpression();

				expectSymbol(')');
				writeXML("symbol", ")");
				tokenizer.advance();
			} else if (tokenizer.symbol() == '-' || tokenizer.symbol() == '~') {
				if (tokenizer.symbol() == '-') writeXML("symbol", "-");
				if (tokenizer.symbol() == '~') writeXML("symbol", "~");
				tokenizer.advance();
				compileTerm();
			}

		}
		// varName | varName '[' expression ']' | subroutineCall -> IDENTIFIER
		// subroutineCall: subroutineName '(' expressionList ')' | (className | varname) '.' subroutineName '(' expressionList ')'
		if (tokenizer.tokenType() == TokenType.IDENTIFIER) {
			// (className | varname) | subroutineName
			String name = expectIdentifier();
			writeXML("identifier", name);
			tokenizer.advance();

			// NOTHING | '[' expression ']' | '(' expressionList ')' | '.' subroutineName '(' expressionList ')'
			if (tokenizer.tokenType() == TokenType.SYMBOL) {
				if (tokenizer.symbol() == '[') {
					writeXML("symbol", "[");
					tokenizer.advance();

					compileExpression();

					expectSymbol(']');
					writeXML("symbol", "]");
					tokenizer.advance();
				}
				if (tokenizer.symbol() == '.') {
					writeXML("symbol", ".");
					tokenizer.advance();

					String subroutineName = expectIdentifier();
					writeXML("identifier", subroutineName);
					tokenizer.advance();
				}
				if (tokenizer.symbol() == '(') {
					writeXML("symbol", "(");
					tokenizer.advance();

					compileExpressionList();

					expectSymbol(')');
					writeXML("symbol", ")");
					tokenizer.advance();
				}
			}
		}
		// integerConstant -> INT_CONST
		if (tokenizer.tokenType() == TokenType.INT_CONST) {
			String constant = "" + tokenizer.intVal();
			writeXML("integerConstant", constant);
			tokenizer.advance();
		}
		// stringConstant -> STRING_CONST
		if (tokenizer.tokenType() == TokenType.STRING_CONST) {
			String constant = tokenizer.stringVal();
			writeXML("stringConstant", constant);
			tokenizer.advance();
		}

		// </term>
		writeXML("term", true);

		// DEBUG_PRINT("</term>");
	}

	/**
	 * Compiles a (possibly empty) comma-separated list of expressions.
	 */
	private void compileExpressionList() {
		// (expression (',' expression)*)?

		// DEBUG_PRINT("<expressionList>");

		// <expressionList>
		writeXML("expressionList", false);

		if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ')') {
			// expression
			compileExpression();

			// (',' expression)*
			while (true) {
				if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
				writeXML("symbol", ",");
				tokenizer.advance();

				compileExpression();
			}
		}

		// </expressionList>
		writeXML("expressionList", true);

		// DEBUG_PRINT("</expressionList>");
	}

	/**
	 * Checks to see if the current token is the expected KeyWord
	 * 
	 * @param expected
	 * @return
	 */
	private void expectKeyWord(KeyWord expected) {
		TokenType token = tokenizer.tokenType();
		KeyWord word = tokenizer.keyWord();

		if (token != TokenType.KEYWORD) {
			try {
				throw new Exception();
			} catch (Exception e) {
				System.out.println("Unexpected token " + token + "!");
				e.printStackTrace();
				System.exit(1);
			}
		}
		if (word != expected) {
			try {
				throw new Exception();
			} catch (Exception e) {
				System.out.println("Unexpected keyword " + word + "!");
				e.printStackTrace();
				System.exit(1);
			}
		}
	}

	/**
	 * Checks to see if the current token is the expected Symbol
	 * 
	 * @param expected
	 * @return
	 */
	private void expectSymbol(char expected) {
		TokenType token = tokenizer.tokenType();
		char symbol = tokenizer.symbol();

		if (token != TokenType.SYMBOL) {
			try {
				throw new Exception();
			} catch (Exception e) {
				System.out.println("Unexpected token " + token + "!");
				e.printStackTrace();
				System.exit(1);
			}
		}
		if (symbol != expected) {
			try {
				throw new Exception();
			} catch (Exception e) {
				System.out.println("Unexpected symbol " + symbol + "!");
				e.printStackTrace();
				System.exit(1);
			}
		}
	}

	/**
	 * Checks to see if the current token is the expected Identifier
	 * 
	 * @param expected
	 * @return
	 */
	private String expectIdentifier() {
		TokenType token = tokenizer.tokenType();

		if (token != TokenType.IDENTIFIER) {
			try {
				throw new Exception();
			} catch (Exception e) {
				System.out.println("Unexpected token " + token + "!");
				e.printStackTrace();
				System.exit(1);
			}
		}
		return tokenizer.identifier();
	}

	/**
	 * Builds a line of XML for Terminals to the output file.
	 * 
	 * @param tag
	 * @param value
	 */
	private void writeXML(String tag, String value) {
		if (value.equals("<")) value = "&lt;";
		if (value.equals(">")) value = "&gt;";
		if (value.equals("&")) value = "&amp;";

		String line = getIndentation() + "<" + tag + "> " + value + " </" + tag + ">\n";

		writeLine(line);
	}

	/**
	 * Builds a line of XML for Non-Terminals to the output file
	 * 
	 * @param tag
	 * @param endTag
	 */
	private void writeXML(String tag, boolean endTag) {
		if (endTag) indents--;

		String line = getIndentation() + "<" + (endTag ? "/" : "") + tag + ">\n";

		writeLine(line);

		if (!endTag) indents++;
	}

	/**
	 * Returns the amount of indentation for the current XML line.
	 * 
	 * @return
	 */
	private String getIndentation() {
		String indentation = "";
		for (int i = 0; i < indents; i++) {
			indentation += "  ";
		}
		return indentation;
	}

	/**
	 * Writes the line to the output file
	 * 
	 * @param line
	 */
	private void writeLine(String line) {
		try {
			bw.write(line);
		} catch (IOException ioe) {
			System.out.println("Couldn't write XML for " + line + "!");
			ioe.printStackTrace();
			System.exit(1);
		}

		// flush();
	}

	/**
	 * Close the BufferedWriter
	 */
	public void close() {
		try {
			bw.close();
		} catch (IOException ioe) {
			System.err.println("Couldn't close BufferedWriter!");
			ioe.printStackTrace();
			System.exit(1);
		}
	}

	/**
	 * Flush the BufferedWriter
	 */
	public void flush() {
		try {
			bw.flush();
			;
		} catch (IOException ioe) {
			System.err.println("Couldn't flush BufferedWriter!");
			ioe.printStackTrace();
			System.exit(1);
		}
	}
}
