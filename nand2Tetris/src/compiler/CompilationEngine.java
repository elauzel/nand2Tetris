package compiler;

import java.io.BufferedWriter;
import java.io.IOException;

import utility.Segment;
import static utility.Utils.*;

/**
 * Recursive top-down parser that effects the actual compilation output. Gets its input from a JackTokenizer and emits its parsed structure into an
 * output file/stream. The output is generated by a series of compilexxx() routines, one for every syntactic element xxx of the Jack grammar. The
 * contract between these routines is that each compilexxx() routine should read the syntactic construct xxx from the input, advance() the tokenizer
 * exactly beyond xxx, and output the parsing of xxx. Thus, compilexxx() may only be called if indeed xxx is the next syntactic element of the
 * input.
 * 
 * @author Jeremy Wayne Gilreath
 *
 */
public class CompilationEngine {
	private static final String			OP_SYMBOLS	= "+-*/&|<>=";
	private static final SymbolTable	TABLE		= new SymbolTable();

	private VMWriter					vmw;
	private BufferedWriter				bw;
	private JackTokenizer				tokenizer;
	private String						className;
	private int							indents;
	private boolean						isVoid;

	/**
	 * Creates a new compilation engine with the given input and output. The next routine called must be compileClass().
	 */
	public CompilationEngine(String outputXML, String outputVM, JackTokenizer jt) {
		bw = bufferedWriterFor(outputXML);
		vmw = new VMWriter(outputVM);
		tokenizer = jt;
		indents = 0;
	}

	/**
	 * Compiles a complete class.
	 */
	public void compileClass() {
		// Class: 'class' className '{' classVarDec* subroutineDec* '}'
		// className: identifier

		// DEBUG_PRINT("<class>");

		TABLE.setScope(Scope.CLASS);

		// <class>
		writeXML("class", false);
		tokenizer.advance();

		// 'class'
		expectKeyWord(KeyWord.CLASS);
		writeXML("keyword", "class");
		tokenizer.advance();

		// className
		className = expectIdentifier();
		writeXML("identifier", className);
		tokenizer.advance();

		// '{'
		expectOpenBrace();

		// classVarDec* -> 'static' | 'field'
		checkForClassVarDecs();

		// subroutineDec* -> 'constructor' | 'function' | 'method'
		checkForSubroutineDecs();

		// '}'
		expectCloseBrace();

		// </class>
		writeXML("class", true);

		// DEBUG_PRINT("</class>");

		if (tokenizer.hasMoreLines()) {
			throwException("Junk after end of class definition!");
		}
	}

	/**
	 * Compiles all subroutine declarations.
	 */
	private void checkForSubroutineDecs() {
		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if ((tokenizer.keyWord() == KeyWord.CONSTRUCTOR)
					|| (tokenizer.keyWord() == KeyWord.FUNCTION || (tokenizer.keyWord() == KeyWord.METHOD))) {
				compileSubroutine();
			} else {
				break;
			}
		}
	}

	/**
	 * Compiles all class variable declarations.
	 */
	private void checkForClassVarDecs() {
		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if ((tokenizer.keyWord() == KeyWord.STATIC) || (tokenizer.keyWord() == KeyWord.FIELD)) {
				compileClassVarDec();
			} else {
				break;
			}
		}
	}

	/**
	 * Compiles a static declaration or a field declaration.
	 */
	private void compileClassVarDec() {
		// ('static' | 'field') type varName (',' varName)* ';'
		// type: 'int' | 'char' | 'boolean' | className
		// varname: identifier
		// className: identifier

		// DEBUG_PRINT("<classVarDec>");

		// <classVarDec>
		writeXML("classVarDec", false);

		// ('static' | 'field')
		expectKeyWord(KeyWord.STATIC, KeyWord.FIELD);

		Identifier varKind;
		if (tokenizer.keyWord() == KeyWord.STATIC) varKind = Identifier.STATIC;
		else
			varKind = Identifier.FIELD;

		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();

		// type -> 'int' | 'char' | 'boolean' | className
		String varType = checkForType();

		// varName (',' varName)* -> identifier
		checkForVarNames(varKind, varType);

		expectSemicolon();

		// </classVarDec>
		writeXML("classVarDec", true);

		// DEBUG_PRINT("</classVarDec>");
	}

	/**
	 * Compiles a complete method, function, or constructor.
	 */
	private void compileSubroutine() {
		// subroutineDec: ('constructor' | 'function' | 'method') ('void' | type) subroutineName '(' parameterList ')' subroutineBody
		// subroutineName: identifier
		// subroutineBody: '{' varDec* statements '}'
		// type: 'int' | 'char' | 'boolean' | className
		// className: identifier

		// DEBUG_PRINT("<subroutine>");

		TABLE.setScope(Scope.SUBROUTINE);

		// <subroutineDec>
		writeXML("subroutineDec", false);

		TABLE.startSubroutine();

		// ('constructor' | 'function' | 'method')
		expectKeyWord(KeyWord.CONSTRUCTOR, KeyWord.FUNCTION, KeyWord.METHOD);
		KeyWord subroutineType = tokenizer.keyWord();
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();

		// ('void' | type) -> 'void' | ('int' | 'char' | 'boolean' | className)
		String varType = checkForType(KeyWord.VOID, KeyWord.INT, KeyWord.CHAR, KeyWord.BOOLEAN);

		// subroutineName -> identifier
		String subroutineName = expectIdentifier();
		writeXML("identifier", subroutineName);
		tokenizer.advance();

		// '(' parameterList ')'
		expectOpenParen();

		compileParameterList();

		expectCloseParen();

		// subroutineBody -> '{' varDec* statements '}'

		// DEBUG_PRINT("<subroutineBody>");

		// <subroutineBody>
		writeXML("subroutineBody", false);

		expectOpenBrace();

		checkForVarDecs();

		writeSubroutineVM(subroutineType, subroutineName, varType);

		compileStatements();

		expectCloseBrace();

		// </subroutineBody>
		writeXML("subroutineBody", true);

		// DEBUG_PRINT("</subroutineBody>");

		// </subroutineDec>
		writeXML("subroutineDec", true);

		// DEBUG_PRINT("</subroutine>");
	}

	/**
	 * Compiles VM for subroutines.
	 * 
	 * @param subroutineType
	 * @param subroutineName
	 */
	private void writeSubroutineVM(KeyWord subroutineType, String subroutineName, String varType) {
		switch (subroutineType) {
			case CONSTRUCTOR:// allocate memory for the subroutine
				int nFields = Math.max(1, TABLE.varCount(Identifier.FIELD)); // OS error to allocate 0 words
				vmw.writeCall("Memory.alloc", nFields);
			case METHOD:// set 'this' to point to the object passed as the first Argument
				vmw.writePush(Segment.ARG, 0);
				vmw.writePop(Segment.POINTER, 0);
				break;
			case FUNCTION:
				int nLocals = TABLE.varCount(Identifier.VAR);
				vmw.writeFunction(className + "." + subroutineName, nLocals, varType);
				break;
			default:
				throwException("Unexpected subroutine type " + subroutineType + "!");
		}
	}

	/**
	 * Compiles a (possibly empty) parameter list, not including the enclosing "()".
	 */
	private void compileParameterList() {
		// ((type varName) (',' type varName)*)?
		// type: 'int' | 'char' | 'boolean' | className
		// varname: identifier
		// className: identifier

		// DEBUG_PRINT("<parameterList>");

		// <parameterList>
		writeXML("parameterList", false);

		if (tokenizer.tokenType() == TokenType.KEYWORD || tokenizer.tokenType() == TokenType.IDENTIFIER) {
			// (type varName) (',' type varName)*
			checkForParameters();
		}

		// </parameterList>
		writeXML("parameterList", true);

		// DEBUG_PRINT("</parameterList>");
	}

	/**
	 * Checks for all parameters in the list.
	 */
	private void checkForParameters() {
		Identifier varKind = Identifier.ARG;
		String varType = ""; // className
		while (true) {
			// type -> 'int' | 'char' | 'boolean' | className
			varType = checkForType(KeyWord.INT, KeyWord.CHAR, KeyWord.BOOLEAN);

			// varName -> identifier
			String varName = expectIdentifier();
			writeXML("identifier", varName);
			tokenizer.advance();

			TABLE.define(varName, varType, varKind);

			// ','
			if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
			writeXML("symbol", ",");
			tokenizer.advance();
		}
	}

	/**
	 * Checks for variable declarations.
	 */
	private void checkForVarDecs() {
		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;
			if (tokenizer.keyWord() == KeyWord.VAR) {
				compileVarDec();
			} else {
				break;
			}
		}
	}

	/**
	 * Compiles a var declaration.
	 */
	private void compileVarDec() {
		// 'var' type varname (',' varName)* ';'
		// type: 'int' | 'char' | 'boolean' | className
		// varname: identifier
		// className: identifier

		// DEBUG_PRINT("<varDec>");

		// <varDec>
		writeXML("varDec", false);

		// 'var'
		expectKeyWord(KeyWord.VAR);
		Identifier varKind = Identifier.VAR;
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();

		// type -> 'int' | 'char' | 'boolean' | className
		String varType = checkForType(KeyWord.INT, KeyWord.CHAR, KeyWord.BOOLEAN);

		// varName (',' varName)* -> identifier
		checkForVarNames(varKind, varType);

		// ';'
		expectSemicolon();

		// </varDec>
		writeXML("varDec", true);

		// DEBUG_PRINT("</varDec>");
	}

	/**
	 * Checks for variable's KeyWord or Identifier type and (if applicable) whether the current function is void.
	 * 
	 * @return
	 */
	private String checkForType(KeyWord... words) {
		String varType;
		if (tokenizer.tokenType() == TokenType.KEYWORD) {
			expectKeyWord(words);
			varType = tokenizer.keyWordStr();
			writeXML("keyword", varType);

			if (tokenizer.keyWord() == KeyWord.VOID) isVoid = true;
		} else {
			varType = expectIdentifier();
			writeXML("identifier", varType);
		}
		tokenizer.advance();
		return varType;
	}

	/**
	 * Checks for all variable names.
	 * 
	 * @param varKind
	 * @param varType
	 */
	private void checkForVarNames(Identifier varKind, String varType) {
		while (true) {
			String varName = expectIdentifier();
			String varScope = TABLE.scopeOf(varName) == null ? "null (object)" : TABLE.scopeOf(varName).toString();
			TABLE.define(varName, varType, varKind);
			// writeXML("identifier", varName);
			writeXML("identifier", "DEFINING in (" + varScope + ") " + varKind + " " + varType + " " + varName + " #"
					+ TABLE.indexOf(varName));
			tokenizer.advance();

			if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
			writeXML("symbol", ",");
			tokenizer.advance();
		}
	}

	/**
	 * Compiles a sequence of statements, not including the enclosing "{}".
	 */
	private void compileStatements() {
		// statement*
		// statement: letStatement | ifStatement | whileStatement | doStatement | returnStatement

		// DEBUG_PRINT("<statements>");

		// <statements>
		writeXML("statements", false);

		while (true) {
			if (tokenizer.tokenType() != TokenType.KEYWORD) break;

			expectKeyWord(KeyWord.LET, KeyWord.IF, KeyWord.WHILE, KeyWord.DO, KeyWord.RETURN);
			KeyWord word = tokenizer.keyWord();
			if (word == KeyWord.LET) {
				compileLet();
			} else if (word == KeyWord.IF) {
				compileIf();
			} else if (word == KeyWord.WHILE) {
				compileWhile();
			} else if (word == KeyWord.DO) {
				compileDo();
			} else if (word == KeyWord.RETURN) {
				compileReturn();
			}
		}

		// </statements>
		writeXML("statements", true);

		// DEBUG_PRINT("</statements>");
	}

	/**
	 * Compiles a do statement.
	 */
	private void compileDo() {
		// 'do' subroutineCall ';'
		// subroutineCall: subroutineName '(' expressionList ')' | (className | varName) '.' subroutineName '(' expressionList ')'
		// subroutineName: identifier
		// className: identifier
		// varName: identifier

		// DEBUG_PRINT("<do>");

		// <do>
		writeXML("doStatement", false);

		// 'do'
		expectDo();

		// subroutineCall -> subroutineName | (className | varName) -> identifier
		String name = expectIdentifier();
		writeXML("identifier", name);
		tokenizer.advance();

		// '.' subroutineName
		boolean isSubroutine = false;
		String subroutineName = "";
		if (tokenizer.tokenType() == TokenType.SYMBOL && tokenizer.symbol() == '.') {
			isSubroutine = true;

			writeXML("symbol", ".");
			tokenizer.advance();

			subroutineName = expectIdentifier();
			writeXML("identifier", subroutineName);
			tokenizer.advance();

			// push THIS
			// vmw.writePush(Segment.POINTER, 0, Identifier.SUBROUTINE);
		}

		// '(' expressionList ')'
		expectOpenParen();

		int nArgs = compileExpressionList();

		writeDoVM(name, isSubroutine, subroutineName, nArgs);

		expectCloseParen();

		// ;
		expectSemicolon();

		// </do>
		writeXML("doStatement", true);

		// DEBUG_PRINT("</do>");
	}

	/**
	 * Expects the KeyWord Do and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectDo() {
		expectKeyWord(KeyWord.DO);
		writeXML("keyword", "do");
		tokenizer.advance();
	}

	/**
	 * Writes the VM for calling Yyy.xx with k + 1 args.
	 * 
	 * @param name
	 * @param isSubroutine
	 * @param subroutineName
	 */
	private void writeDoVM(String name, boolean isSubroutine, String subroutineName, int nArgs) {
		// write the call to Yyy.xxx with k args
		writeCallVM(name, isSubroutine, subroutineName, nArgs);

		// pop and ignore the returned value if the method/function is void
		if (isVoid) {
			vmw.writePop(Segment.TEMP, 0);
			isVoid = false;
		}
	}

	/**
	 * Writes the VM call to Yyy.xxx with k args.
	 * 
	 * @param name
	 * @param isSubroutine
	 * @param subroutineName
	 * @param nArgs
	 */
	private void writeCallVM(String name, boolean isSubroutine, String subroutineName, int nArgs) {
		if (isSubroutine) {
			// push Args for the function you are calling
			vmw.writeCall(name + "." + subroutineName, nArgs);
		}
	}

	/**
	 * Compiles a let statement.
	 */
	private void compileLet() {
		// 'let' varName ('[' expression ']')? '=' expression ';'
		// varname: identifier

		// DEBUG_PRINT("<let>");

		// <let>
		writeXML("letStatement", false);

		// 'let'
		expectLet();

		// varName -> identifier
		String varName = expectIdentifier();
		writeXML("identifier", varName);
		tokenizer.advance();

		// ('[' expression ']')?
		boolean varArray = false;
		if (tokenizer.tokenType() == TokenType.SYMBOL && tokenizer.symbol() == '[') {
			varArray = true;

			writeXML("symbol", "[");
			tokenizer.advance();

			compileExpression();

			expectCloseBracket();
		}

		// '='
		expectEquals();

		// expression
		compileExpression();

		// point the virtual 'that' segment via pointer 1, then access the desired array entry via 'that' 0 references
		writeLetVM(varName, varArray);

		// ;
		expectSemicolon();

		// </let>
		writeXML("letStatement", true);

		// DEBUG_PRINT("</let>");
	}

	/**
	 * Expects the KeyWord Let, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectLet() {
		expectKeyWord(KeyWord.LET);
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();
	}

	/**
	 * Writes VM for pointing the virtual 'that' segment via pointer 1, then accessing the desired array entry via 'that' 0 references
	 * 
	 * @param varName
	 * @param varArray
	 */
	private void writeLetVM(String varName, boolean varArray) {
		if (varArray) {
			vmw.writePop(Segment.TEMP, 0);
			accessArray(varName);
			vmw.writePush(Segment.TEMP, 0);
			vmw.writePop(Segment.THAT, 0);
		} else {
			Identifier varKind = TABLE.kindOf(varName);
			Segment varSeg = TABLE.kindToSegment(varKind);
			int varIndex = TABLE.indexOf(varName);
			vmw.writePop(varSeg, varIndex, varKind, varName);
		}
	}

	/**
	 * Point the virtual 'that' segment (using pointer 1) to the address of the desired array entry
	 * 
	 * @param varName
	 */
	private void accessArray(String varName) {
		Identifier varKind = TABLE.kindOf(varName);
		Segment varSeg = TABLE.kindToSegment(varKind);
		int varIndex = TABLE.indexOf(varName);
		vmw.writePush(varSeg, varIndex, varKind, varName);
		vmw.writeArithmetic(Command.ADD);
		vmw.writePop(Segment.POINTER, 1);
	}

	/**
	 * Compiles a while statement.
	 */
	private void compileWhile() {
		// 'while' '(' expression ')' '{' statements '}'

		// DEBUG_PRINT("<while>");

		// <while>
		writeXML("whileStatement", false);

		// 'while'
		expectWhile();

		String expressionLabel = uniqueLabel("WHILE_EXP");
		vmw.writeLabel(expressionLabel);

		// '(' expression ')'
		expectOpenParen();

		compileExpression();

		String endLabel = uniqueLabel("WHILE_END");
		vmw.writeIf(endLabel);

		expectCloseParen();

		// '{' statements '}'
		expectOpenBrace();

		compileStatements();

		expectCloseBrace();

		vmw.writeGoto(expressionLabel);
		vmw.writeLabel(endLabel);

		// </while>
		writeXML("whileStatement", true);

		// DEBUG_PRINT("</while>");
	}

	/**
	 * Expects the KeyWord While, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectWhile() {
		expectKeyWord(KeyWord.WHILE);
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();
	}

	/**
	 * Compiles a return statement.
	 */
	private void compileReturn() {
		// 'return' expression? ';'

		// DEBUG_PRINT("<return>");

		// <return>
		writeXML("returnStatement", false);

		// 'return'
		expectReturn();

		// expression?
		if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ';') {
			compileExpression();
		} else {
			vmw.writePush(Segment.CONST, 0);
		}

		vmw.writeReturn();

		expectSemicolon();

		// </return>
		writeXML("returnStatement", true);

		// DEBUG_PRINT("</return>");
	}

	/**
	 * Expects the KeyWord Return, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectReturn() {
		expectKeyWord(KeyWord.RETURN);
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();
	}

	/**
	 * Compiles an if statement, possibly with a trailing else clause.
	 */
	private void compileIf() {
		// 'if' '(' expression ')' '{' statements '}' ('else' '{' statements '}')?

		// DEBUG_PRINT("<if>");

		// <if>
		writeXML("ifStatement", false);

		// 'if'
		expectIf();

		// '(' expression ')'
		expectOpenParen();

		compileExpression();

		expectCloseParen();

		String trueLabel = uniqueLabel("IF_TRUE");
		vmw.writeIf(trueLabel);

		// '{' statements '}'
		expectOpenBrace();

		compileStatements();

		expectCloseBrace();

		String falseLabel = uniqueLabel("IF_FALSE");
		// vmw.writeGoto(l2);

		// ('else' '{' statements '}')?
		if (tokenizer.tokenType() == TokenType.KEYWORD && tokenizer.keyWord() == KeyWord.ELSE) {
			writeXML("keyword", tokenizer.keyWordStr());
			tokenizer.advance();

			vmw.writeGoto(falseLabel);
			vmw.writeLabel(trueLabel);

			// '{' statements '}'
			expectOpenBrace();

			compileStatements();

			vmw.writeLabel(falseLabel);

			expectCloseBrace();
		} else {
			vmw.writeLabel(trueLabel);
		}

		// </if>
		writeXML("ifStatement", true);

		// DEBUG_PRINT("</if>");
	}

	/**
	 * Expects the KeyWord If, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectIf() {
		expectKeyWord(KeyWord.IF);
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();
	}

	/**
	 * Compiles an expression.
	 */
	private void compileExpression() {
		// term (op term)*
		// op: '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='

		// DEBUG_PRINT("<expression>");

		// <expression>
		writeXML("expression", false);

		// term (op term)*
		checkForTerms();

		// </expression>
		writeXML("expression", true);

		// DEBUG_PRINT("</expression>");
	}

	/**
	 * Checks for all terms.
	 */
	private void checkForTerms() {
		char symbol = ' ';
		boolean op = false;
		while (true) {
			compileTerm();

			if (op == true) writeRPN(symbol);

			symbol = tokenizer.symbol();
			if (tokenizer.tokenType() != TokenType.SYMBOL || OP_SYMBOLS.indexOf(symbol) == -1) break;
			writeXML("symbol", "" + symbol);
			tokenizer.advance();

			op = true;
		}
	}

	/**
	 * Writes term (op term)* in Reverse Polish Notation
	 * 
	 * @param symbol
	 */
	private void writeRPN(char symbol) {
		switch (symbol) {
			case '+':
				vmw.writeArithmetic(Command.ADD);
				break;
			case '-':
				vmw.writeArithmetic(Command.SUB);
				break;
			case '*':
				vmw.writeCall("Math.multiply", 2);
				break;
			case '/':
				vmw.writeCall("Math.divide", 2);
				break;
			case '&':
				vmw.writeArithmetic(Command.AND);
				break;
			case '|':
				vmw.writeArithmetic(Command.OR);
				break;
			case '<':
				vmw.writeArithmetic(Command.LT);
				break;
			case '>':
				vmw.writeArithmetic(Command.GT);
				break;
			case '=':
				// vmw.writeArithmetic(Command.EQ);
				break;
			default:
				throwException("Unexpected symbol " + symbol + "!");
		}
	}

	/**
	 * Compiles a term. This routine is faced with a slight difficulty when trying to decide between some of the alternative parsing rules.
	 * Specifically, if the current token is an identifier, the routine must distinguish between a variable, an array entry, and a subroutine call.
	 * A single look-ahead token, which may be one of "[", "(", or "." suffices to distinguish between the three possibilities. Any other token is
	 * not part of this term and should not be advanced over.
	 */
	private void compileTerm() {
		// integerConstant | stringConstant | keywordConstant | varName | varName '[' expression ']' | subroutineCall | '(' expression ')' | unaryOp
		// term
		// varname: identifier
		// subroutineCall: subroutineName '(' expressionList ')' | (className | varname) '.' subroutineName '(' expressionList ')'
		// unaryOp: '-' | '~'
		// keywordConstant: 'true' | 'false' | 'null' | 'this'

		// DEBUG_PRINT("<term>");

		// <term>
		writeXML("term", false);

		// keywordConstant -> 'true' | 'false' | 'null' | 'this' -> KEYWORD
		if (tokenizer.tokenType() == TokenType.KEYWORD) {
			writeTermKeyWord();
		}

		// '(' expression ')' | unaryOp term ->
		// '(' expression ')' | ('-' | '~') term -> SYMBOL
		char symbol = tokenizer.symbol();
		if (tokenizer.tokenType() == TokenType.SYMBOL) {
			writeTermSymbols(symbol);
		}

		// varName | varName '[' expression ']' | subroutineCall -> IDENTIFIER
		// subroutineCall: subroutineName '(' expressionList ')' | (className | varname) '.' subroutineName '(' expressionList ')'
		if (tokenizer.tokenType() == TokenType.IDENTIFIER) {
			writeTermIdentifiers();
		}

		// integerConstant -> INT_CONST
		if (tokenizer.tokenType() == TokenType.INT_CONST) {
			writeTermIntConst();
		}

		// stringConstant -> STRING_CONST
		if (tokenizer.tokenType() == TokenType.STRING_CONST) {
			writeTermStringConst();
		}

		// </term>
		writeXML("term", true);

		// DEBUG_PRINT("</term>");
	}

	/**
	 * Writes XML and VM for the expected Term String constant.
	 */
	private void writeTermStringConst() {
		String constant = tokenizer.stringVal();
		writeXML("stringConstant", constant);
		tokenizer.advance();

		int length = constant.length();
		vmw.writeCall("String.new", length);
		// for (int i = 0; i < length; i++) {
		// vmw.writeCall("String.appendChar", constant.charAt(i));
		// }
	}

	/**
	 * Writes XML and VM for the expected Term Integer constant.
	 */
	private void writeTermIntConst() {
		int constant = tokenizer.intVal();
		writeXML("integerConstant", "" + constant);
		tokenizer.advance();

		vmw.writePush(Segment.CONST, constant);
	}

	/**
	 * Writes XML and VM for the expected Term Identifiers.
	 */
	private void writeTermIdentifiers() {
		// (className | varname) | subroutineName
		String name = expectIdentifier();
		writeXML("identifier", name);
		tokenizer.advance();

		// NOTHING | '[' expression ']' | '(' expressionList ')' | '.' subroutineName '(' expressionList ')'
		if (tokenizer.tokenType() == TokenType.SYMBOL) {
			if (tokenizer.symbol() == '[') {
				writeXML("symbol", "[");
				tokenizer.advance();

				compileExpression();

				expectCloseBracket();
			}

			String subroutineName = "";
			boolean isSubroutine = false;
			if (tokenizer.symbol() == '.') {
				isSubroutine = true;
				writeXML("symbol", ".");
				tokenizer.advance();

				subroutineName = expectIdentifier();
				writeXML("identifier", subroutineName);
				tokenizer.advance();
			}

			// '(' expressionList ')'
			if (tokenizer.symbol() == '(') {
				writeXML("symbol", "(");
				tokenizer.advance();

				int nArgs = compileExpressionList();

				writeCallVM(name, isSubroutine, subroutineName, nArgs);

				expectCloseParen();
			}
		}
	}

	/**
	 * Writes XML and VM for the expected Term Symbols.
	 * 
	 * @param symbol
	 */
	private void writeTermSymbols(char symbol) {
		// '(' expressionList ')'
		if (symbol == '(') {
			writeXML("symbol", "(");
			tokenizer.advance();

			compileExpression();

			expectCloseParen();
		} else if (symbol == '-' || symbol == '~') {
			writeTermUnaryOps(symbol);
		}
	}

	/**
	 * Writes XML and VM for the expected Term KeyWord.
	 */
	private void writeTermKeyWord() {
		expectKeyWord(KeyWord.TRUE, KeyWord.FALSE, KeyWord.NULL, KeyWord.THIS);
		KeyWord word = tokenizer.keyWord();
		writeXML("keyword", tokenizer.keyWordStr());
		tokenizer.advance();

		switch (word) {
			case FALSE:
				vmw.writePush(Segment.CONST, 0);
				break;
			case NULL:
				vmw.writePush(Segment.CONST, 0);
				break;
			case THIS:
				vmw.writePush(Segment.POINTER, 0);
				break;
			case TRUE:
				vmw.writePush(Segment.CONST, 1);
				vmw.writeArithmetic(Command.NEG);
				break;
			default:
				throwException("Unexpected KeyWord " + word + "!");
		}
	}

	/**
	 * Writes XML and VM for the expected Term unary operators.
	 * 
	 * @param symbol
	 */
	private void writeTermUnaryOps(char symbol) {
		writeXML("symbol", "" + symbol);
		tokenizer.advance();

		compileTerm();

		if (symbol == '-') {
			vmw.writeArithmetic(Command.NEG);
		} else {
			vmw.writeArithmetic(Command.NOT);
		}
	}

	/**
	 * Compiles a (possibly empty) comma-separated list of expressions.
	 */
	private int compileExpressionList() {
		// (expression (',' expression)*)?

		// DEBUG_PRINT("<expressionList>");

		// <expressionList>
		writeXML("expressionList", false);

		int nExpressions = 0;
		if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ')') {
			// expression (',' expression)*
			nExpressions = checkForExpressions();
		}

		// </expressionList>
		writeXML("expressionList", true);

		// DEBUG_PRINT("</expressionList>");

		return nExpressions;
	}

	/**
	 * Checks for all expressions.
	 */
	private int checkForExpressions() {
		int nExpressions = 0;
		while (true) {
			compileExpression();
			nExpressions++;

			if (tokenizer.tokenType() != TokenType.SYMBOL || tokenizer.symbol() != ',') break;
			writeXML("symbol", ",");
			tokenizer.advance();
		}
		return nExpressions;
	}

	/**
	 * Checks to see if the current token matches the expected KeyWord (or one of them)
	 * 
	 * @param expected
	 * @return
	 */
	private void expectKeyWord(KeyWord... expected) {
		TokenType token = tokenizer.tokenType();
		KeyWord currentWord = tokenizer.keyWord();
		boolean matches = false;

		if (token != TokenType.KEYWORD) throwException("Unexpected token " + token + "!");

		for (KeyWord expectedWord : expected) {
			if (currentWord == expectedWord) {
				matches = true;
				break;
			}
		}

		if (!matches) throwException("Unexpected keyword " + currentWord + "!");
	}

	/**
	 * Checks to see if the current token is the expected Symbol
	 * 
	 * @param expected
	 * @return
	 */
	private void expectSymbol(char expected) {
		TokenType token = tokenizer.tokenType();
		char symbol = tokenizer.symbol();

		if (token != TokenType.SYMBOL) throwException("Unexpected token " + token + "!");
		if (symbol != expected) throwException("Unexpected symbol " + symbol + "!");
	}

	/**
	 * Expects a closed brace and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectCloseBrace() {
		expectSymbol('}');
		writeXML("symbol", "}");
		tokenizer.advance();
	}

	/**
	 * Expects an open brace and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectOpenBrace() {
		expectSymbol('{');
		writeXML("symbol", "{");
		tokenizer.advance();
	}

	/**
	 * Expects a closed parenthesis and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectCloseParen() {
		expectSymbol(')');
		writeXML("symbol", ")");
		tokenizer.advance();
	}

	/**
	 * Expects an open parenthesis and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectOpenParen() {
		expectSymbol('(');
		writeXML("symbol", "(");
		tokenizer.advance();
	}

	/**
	 * Expects a semicolon and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectSemicolon() {
		expectSymbol(';');
		writeXML("symbol", ";");
		tokenizer.advance();
	}

	/**
	 * Expects an equals and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectEquals() {
		expectSymbol('=');
		writeXML("symbol", "=");
		tokenizer.advance();
	}

	/**
	 * Expects a closed bracket and, if found, writes it to XML and advances the tokenizer.
	 */
	private void expectCloseBracket() {
		expectSymbol(']');
		writeXML("symbol", "]");
		tokenizer.advance();
	}

	/**
	 * Checks to see if the current token is the expected Identifier
	 * 
	 * @param expected
	 * @return
	 */
	private String expectIdentifier() {
		TokenType token = tokenizer.tokenType();

		if (token != TokenType.IDENTIFIER) throwException("Unexpected token " + token + "!");
		return tokenizer.identifier();
	}

	/**
	 * Builds a line of XML for Terminals to the output file.
	 * 
	 * @param tag
	 * @param value
	 */
	private void writeXML(String tag, String value) {
		if (value.equals("<")) value = "&lt;";
		if (value.equals(">")) value = "&gt;";
		if (value.equals("&")) value = "&amp;";

		String line = getIndentation() + "<" + tag + "> " + value + " </" + tag + ">";
		writeLine(line);
	}

	/**
	 * Builds a line of XML for Non-Terminals to the output file
	 * 
	 * @param tag
	 * @param endTag
	 */
	private void writeXML(String tag, boolean endTag) {
		if (endTag) indents--;

		String line = getIndentation() + "<" + (endTag ? "/" : "") + tag + ">";
		writeLine(line);

		if (!endTag) indents++;
	}

	/**
	 * Returns the amount of indentation for the current XML line.
	 * 
	 * @return
	 */
	private String getIndentation() {
		String indentation = "";
		for (int i = 0; i < indents; i++) {
			indentation += "  ";
		}
		return indentation;
	}

	/**
	 * Writes the line to the output file
	 * 
	 * @param line
	 */
	private void writeLine(String line) {
		try {
			bw.write(line + "\n");
		} catch (IOException ioe) {
			System.out.println("Couldn't write XML for " + line + "!");
			ioe.printStackTrace();
			System.exit(1);
		}

		flush();
	}

	/**
	 * Prints all key:value pairs for the SymbolTable
	 */
	public void printTable() {
		TABLE.printAll();
	}

	/**
	 * Close the BufferedWriter
	 */
	public void close() {
		try {
			bw.close();
		} catch (IOException ioe) {
			System.err.println("Couldn't close BufferedWriter!");
			ioe.printStackTrace();
			System.exit(1);
		}
	}

	/**
	 * Flush the BufferedWriter
	 */
	private void flush() {
		try {
			bw.flush();
			;
		} catch (IOException ioe) {
			System.err.println("Couldn't flush BufferedWriter!");
			ioe.printStackTrace();
			System.exit(1);
		}
	}
}
